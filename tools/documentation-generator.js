import fs from 'fs/promises';
import path from 'path';

/**
 * Documentation Generator Tool for KaibanJS
 * Saves generated documentation to the outputs directory
 */
class DocumentationGeneratorTool {
  constructor() {
    this.name = 'documentationGenerator';
    this.description = 'Saves generated documentation to the outputs directory with proper formatting and metadata';
    this.parameters = {
      type: 'object',
      properties: {
        content: {
          type: 'string',
          description: 'The markdown content to save'
        },
        title: {
          type: 'string', 
          description: 'The title of the document'
        },
        type: {
          type: 'string',
          description: 'The type/category of document (e.g., requirements, technical, design)',
          default: 'document'
        },
        format: {
          type: 'string',
          description: 'The format of the document (markdown, txt, etc)',
          default: 'markdown'
        }
      },
      required: ['content', 'title']
    };
  }

  async invoke({ content, title, type = 'document', format = 'markdown' }) {
    try {
      console.log(`üìù Documentation generator called with title: "${title}"`);
      console.log(`üìù Content length: ${content ? content.length : 0} characters`);
      console.log(`üìù Type: ${type}, Format: ${format}`);

      if (!content || typeof content !== 'string') {
        throw new Error('Content must be a non-empty string');
      }

      if (!title || typeof title !== 'string') {
        throw new Error('Title must be a non-empty string');
      }

      // Ensure outputs directory exists
      const outputsDir = './outputs';
      try {
        await fs.mkdir(outputsDir, { recursive: true });
      } catch (mkdirError) {
        console.log(`üìÅ Directory ${outputsDir} already exists or created`);
      }

      // Create subdirectory based on type
      const typeDir = path.join(outputsDir, `${type}-documents`);
      try {
        await fs.mkdir(typeDir, { recursive: true });
      } catch (mkdirError) {
        console.log(`üìÅ Directory ${typeDir} already exists or created`);
      }

      // Generate filename with timestamp
      const timestamp = new Date().toISOString().split('T')[0];
      const sanitizedTitle = title.toLowerCase()
        .replace(/[^a-z0-9\s-]/g, '')
        .replace(/\s+/g, '-')
        .substring(0, 50);
      
      const extension = format === 'markdown' ? 'md' : format;
      const filename = `${sanitizedTitle}-${timestamp}.${extension}`;
      const filepath = path.join(typeDir, filename);

      // Add document metadata header
      const documentHeader = `<!-- filepath: ${filepath} -->
# ${title}

**Document Type:** ${type.charAt(0).toUpperCase() + type.slice(1)}  
**Generated:** ${new Date().toISOString()}  
**Project:** Rhajaina AI Chat Application

---

`;

      const fullContent = documentHeader + content + '\n\n---\n\n*Generated by Rhajaina Requirements Management System*';

      // Write the file
      await fs.writeFile(filepath, fullContent, 'utf8');
      
      console.log(`‚úÖ Documentation saved to: ${filepath}`);
      console.log(`üìä File size: ${fullContent.length} characters`);

      return {
        success: true,
        filepath: filepath,
        filename: filename,
        size: fullContent.length,
        message: `Document "${title}" saved successfully`
      };

    } catch (error) {
      console.error('‚ùå Documentation generator error:', error);
      return {
        success: false,
        error: error.message,
        message: `Failed to save document: ${error.message}`
      };
    }
  }
}

// Create instance and export both function and class
const documentationGeneratorInstance = new DocumentationGeneratorTool();

// Legacy function export for backward compatibility
export async function documentationGenerator(params) {
  return await documentationGeneratorInstance.invoke(params);
}

// Export the tool instance for KaibanJS
export const documentationGeneratorTool = documentationGeneratorInstance;

// Default export
export default documentationGeneratorInstance;