import fs from 'fs/promises';
import path from 'path';

/**
 * Documentation Generator Tool for KaibanJS
 * Saves generated documentation to the outputs directory
 */
class DocumentationGeneratorTool {
  constructor() {
    this.name = 'documentationGenerator';
    this.description = 'Saves generated documentation to the outputs directory with proper formatting and metadata';
    this.parameters = {
      type: 'object',
      properties: {
        content: {
          type: 'string',
          description: 'The markdown content to save'
        },
        title: {
          type: 'string', 
          description: 'The title of the document'
        },
        type: {
          type: 'string',
          description: 'The type/category of document (e.g., requirements, technical, design)',
          default: 'document'
        },
        format: {
          type: 'string',
          description: 'The format of the document (markdown, txt, etc)',
          default: 'markdown'
        }
      },
      required: ['content', 'title']
    };
  }

  async invoke({ title, content, type = 'document', format = 'markdown' }) {
    try {
      // Validate required parameters
      if (!title || title === 'undefined') {
        throw new Error('Title parameter is required and cannot be undefined');
      }

      // Handle content parameter - convert to string if it's an object
      let contentStr = '';
      if (typeof content === 'string') {
        contentStr = content;
      } else if (typeof content === 'object' && content !== null) {
        // If content is an object, try to extract string value or stringify it
        if (content.toString && content.toString !== Object.prototype.toString) {
          contentStr = content.toString();
        } else {
          contentStr = JSON.stringify(content, null, 2);
        }
      } else if (content) {
        contentStr = String(content);
      } else {
        contentStr = '';
      }

      console.log('üìù Documentation generator called with title:', JSON.stringify(title));
      console.log('üìù Content length:', contentStr.length, 'characters');
      console.log('üìù Type:', type, ', Format:', format);
      
      if (contentStr.length === 0) {
        console.log('üìù Content preview: NO CONTENT');
      } else {
        console.log('üìù Content preview:', contentStr.substring(0, 100) + (contentStr.length > 100 ? '...' : ''));
      }

      // More detailed validation
      if (title === undefined || title === null) {
        console.error('‚ùå Title is undefined or null');
        throw new Error('Title parameter is required and cannot be undefined');
      }

      if (content === undefined || content === null) {
        console.error('‚ùå Content is undefined or null');
        throw new Error('Content parameter is required and cannot be undefined');
      }

      if (!contentStr || typeof contentStr !== 'string' || contentStr.trim().length === 0) {
        console.error('‚ùå Content validation failed:', { content: contentStr, type: typeof contentStr, length: contentStr ? contentStr.length : 'N/A' });
        throw new Error('Content must be a non-empty string with actual content');
      }

      if (!title || typeof title !== 'string' || title.trim().length === 0) {
        console.error('‚ùå Title validation failed:', { title, type: typeof title });
        throw new Error('Title must be a non-empty string');
      }

      // Ensure outputs directory exists
      const outputsDir = './outputs';
      try {
        await fs.mkdir(outputsDir, { recursive: true });
      } catch (mkdirError) {
        console.log(`üìÅ Directory ${outputsDir} already exists or created`);
      }

      // Create subdirectory based on type
      const typeDir = path.join(outputsDir, `${type}-documents`);
      try {
        await fs.mkdir(typeDir, { recursive: true });
      } catch (mkdirError) {
        console.log(`üìÅ Directory ${typeDir} already exists or created`);
      }

      // Generate filename with timestamp
      const timestamp = new Date().toISOString().split('T')[0];
      const sanitizedTitle = title.toLowerCase()
        .replace(/[^a-z0-9\s-]/g, '')
        .replace(/\s+/g, '-')
        .substring(0, 50);
      
      const extension = format === 'markdown' ? 'md' : format;
      const filename = `${sanitizedTitle}-${timestamp}.${extension}`;
      const filepath = path.join(typeDir, filename);

      // Add document metadata header
      const documentHeader = `<!-- filepath: ${filepath} -->
# ${title}

**Document Type:** ${type.charAt(0).toUpperCase() + type.slice(1)}  
**Generated:** ${new Date().toISOString()}  
**Project:** Rhajaina AI Chat Application

---

`;

      const fullContent = documentHeader + contentStr + '\n\n---\n\n*Generated by Rhajaina Requirements Management System*';

      // Write the file
      await fs.writeFile(filepath, fullContent, 'utf8');
      
      console.log(`‚úÖ Documentation saved to: ${filepath}`);
      console.log(`üìä File size: ${fullContent.length} characters`);

      return {
        success: true,
        filepath: filepath,
        filename: filename,
        size: fullContent.length,
        message: `Document "${title}" saved successfully to ${filepath}`
      };

    } catch (error) {
      console.error('‚ùå Documentation generator error:', error);
      console.error('‚ùå Error stack:', error.stack);
      console.error('‚ùå Parameters received:', { content: typeof content, title: typeof title, type, format });
      return {
        success: false,
        error: error.message,
        message: `Failed to save document: ${error.message}`
      };
    }
  }
}

// Create instance and export both function and class
const documentationGeneratorInstance = new DocumentationGeneratorTool();

// Legacy function export for backward compatibility
export async function documentationGenerator(params) {
  return await documentationGeneratorInstance.invoke(params);
}

// Export the tool instance for KaibanJS
export const documentationGeneratorTool = documentationGeneratorInstance;

// Default export
export default documentationGeneratorInstance;