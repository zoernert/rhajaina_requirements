import { Tool } from "@langchain/core/tools";
import { z } from "zod";
import { writeFileSync, ensureDirSync } from 'fs-extra';
import { join } from 'path';

export class DocumentationGenerator extends Tool {
  name = 'documentation-generator';
  description = 'Generates and saves technical documentation in various formats. Input should be a JSON string with: {"content": "text", "title": "doc title", "type": "requirements|architecture|api|implementation", "format": "markdown|json|html"}';
  
  schema = z.object({
    input: z.string().optional().describe("JSON string containing content, title, type, and format")
  }).transform((data) => data.input);
  
  async _call(input: string | undefined): Promise<string> {
    try {
      if (!input) {
        return JSON.stringify({
          error: 'No input provided. Expected JSON string with content, title, and type fields.'
        });
      }
      
      const params = JSON.parse(input);
      const { content, title, type, format = 'markdown' } = params;
      
      if (!content || !title || !type) {
        return JSON.stringify({
          error: 'Missing required fields: content, title, and type are required'
        });
      }
      
      // Ensure output directory exists
      const outputDir = join('./outputs', `${type}-documents`);
      ensureDirSync(outputDir);
      
      // Generate filename with timestamp
      const timestamp = new Date().toISOString().split('T')[0];
      const filename = `${title.replace(/\s+/g, '-').toLowerCase()}-${timestamp}.${format}`;
      const filepath = join(outputDir, filename);
      
      // Format content based on type and format
      let formattedContent = content;
      
      if (format === 'markdown') {
        formattedContent = this.formatAsMarkdown(content, title, type);
      } else if (format === 'json') {
        formattedContent = this.formatAsJson(content, title, type);
      } else if (format === 'html') {
        formattedContent = this.formatAsHtml(content, title, type);
      }
      
      // Save to file
      writeFileSync(filepath, formattedContent);
      
      return JSON.stringify({
        success: true,
        filepath,
        message: `Documentation saved: ${filename}`
      });
    } catch (error) {
      return JSON.stringify({
        error: 'Invalid input format. Expected JSON with content, title, type, and optional format fields.',
        details: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }
  
  private formatAsMarkdown(content: string, title: string, type: string): string {
    return `# ${title}

**Document Type:** ${type.charAt(0).toUpperCase() + type.slice(1)}  
**Generated:** ${new Date().toISOString()}  
**Project:** Rhajaina AI Chat Application

---

${content}

---

*Generated by Rhajaina Requirements Management System*
`;
  }
  
  private formatAsJson(content: string, title: string, type: string): string {
    return JSON.stringify({
      title,
      type,
      generated: new Date().toISOString(),
      project: "Rhajaina AI Chat Application",
      content,
      metadata: {
        generator: "Rhajaina Requirements Management System"
      }
    }, null, 2);
  }
  
  private formatAsHtml(content: string, title: string, type: string): string {
    return `<!DOCTYPE html>
<html>
<head>
    <title>${title}</title>
    <meta charset="UTF-8">
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        h1 { color: #333; border-bottom: 2px solid #007acc; }
        .metadata { background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 20px 0; }
        .content { line-height: 1.6; }
    </style>
</head>
<body>
    <h1>${title}</h1>
    <div class="metadata">
        <strong>Document Type:</strong> ${type}<br>
        <strong>Generated:</strong> ${new Date().toISOString()}<br>
        <strong>Project:</strong> Rhajaina AI Chat Application
    </div>
    <div class="content">
        ${content.replace(/\n/g, '<br>')}
    </div>
    <hr>
    <em>Generated by Rhajaina Requirements Management System</em>
</body>
</html>`;
  }
}

// Export an instance for easy use
export const documentationGenerator = new DocumentationGenerator();